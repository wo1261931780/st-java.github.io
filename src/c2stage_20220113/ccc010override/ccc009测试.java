package c2stage_20220113.ccc010override;

public class ccc009测试 {
    public static void main(String[] args) {
        ccc007fu x1 = new ccc007fu();
        // 父类中创建对象，然后调用父类中的方法
        // 先把参数传递给父类，然后调用父类的方法
        x1.call("1114父类");
        System.out.println("+++++++++++下面是子类+++++++++++");
        ccc008zi x2 = new ccc008zi();
        // 子类中创建对象，然后调用方法
        // 传递的参数是123，但是子类重写父类的方法
        // 传递给子类，因为子类重写了方法，所以有子类的内容出现
        // 子类中，调用了父类的方法，所以也会显示父类方法的内容
        x2.call("123");
        // 子类中，虽然继承了父类，但是重写后，父类的原方法show会彻底消失，不会执行
    }

    // 如果父类中的方法使用private修饰，
    // 那么该方法无法被访问，进而也就无法被重写
    // 这种情况下，即使方法名相同，子类中的方法也无法添加override，
    // 同时，子类中的同名方法会被认定为新方法
    // 就实际效果来说，还是重写了，只不过无法添加注解而已

    // 不管子类中如何表现，最终是按照override能否定义成功，来判断是否重写
}
